# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature closeable
#
# -----------------------------------------------------------------------

# closeable -- effect for handling a resource that can be opened an closed
#
# closeable provides an operation 'open' that opens and file and stores a
# file handler (currently an integer representing a file descriptor) in
# mutable state.
#
Resource ref : hasHash Resource is
  # NYI: cannot specify open because number of arguments might differ
  # open is abstract
  # perhaps we don't even need it.

  close outcome unit is abstract

  hash u64 is abstract

  infix = (o Resource) bool is
    hash ≟ o.hash

closeable : effect effectMode.plain
is

  # (mutable) map/set of open resources
  private open_resources := CTrie Resource Resource

  # install this effect and execute 'f' in the effect's environment
  with(R type, f ()->R) R is
    (run R (()->
      ret := f.call
      if closeable.env.open_resources.size ≟ 0
        ret
      else
        panic "unclosed resource fd {f}") ((_)->panic "closeable aborted unexpectedly!"))

  # open an abstract resource
  private open(r Resource) unit is
    # NYI: do we need some kind of duplicate handling?
    # this is currently changes nothing if r is already in open_resources
    open_resources.add r r

  # close an abstract resource, return an error if trying to close a resource
  # that has not been opened.
  private close(r Resource) outcome unit is
    match open_resources.remove r
      res Resource => res.close
      n (CTrie Resource Resource).NOTFOUND => error "tried closing resource that was not opened in the first place"

# convenience routine to create a new instance of 'closeable' and run 'f' in
# it.
#
closeable(R type, f ()->R) =>
  closeable.with f
